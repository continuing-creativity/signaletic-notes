{
    // Each node in the graph is given a unique name, and are defined declaratively by type.
    // Any "options" (static configuration), such as oscillator waveform type,
    // can be specified within the Node definition.
    nodes: {
        frequency: {
            // This will be implemented using the poorly-named ConstantSourceNode or its polyfill.
            type: "signal.value",
            value: 440
        },

        amplitude: {
            type: "signal.value",
            value: 1.0
        },

        ratio: {
            type: "signal.value",
            value: 2
        },

        index: {
            type: "signal.value",
            value: 5
        },

        noteGate: {
            type: "signal.value",
            value: 0.0
        },

        envelope: {
            // This will be a custom object that controls the AudioParam
            // it is connected when the "gate" signal transitions above/below 0.
            type: "signal.envGen",

            // This is an custom envelope with user-defined breakpoints.
            // Reusable envelope shapes will be provided and be specified by type name.
            envelope: {
                levels: [0, 1, 0.75, 0.6, 0],
                times: [0.1, 0.1, 0.3, 0.1],
                sustainPoint: 2
            }
        },

        modulatorFrequency: {
            // This will be implemented as a two-input GainNode
            // that assigns its second input to the "gain" AudioParam
            type: "signal.mul"
        },

        deviation: {
            type: "signal.mul"
        },

        modulatorAmplitudeGain: {
            type: "signal.mul"
        },

        modulator: {
            type: "signal.oscillator",
            shape: "sine"
        },

        modulatorOutputGain: {
            type: "signal.gain"
        },

        carrier: {
            type: "signal.oscillator",
            shape: "sine"
        },

        envelopeGain: {
            type: "signal.gain"
        },

        outputGain: {
            type: "signal.gain"
        }
    },

    // The "connections" block declares the wiring
    // between Nodes in the graph.
    // Connections are declared with the source Node (i.e. the Node you want to connect up to the input of another) as the key,
    // and a path into the target node on the right (or an array of them for multiple connections).
    connections: {
        "noteGate.outputs.0": "envelope.gate",

        // This is an example of one node being connected
        // as an input to two others.
        "frequency.outputs.0": [
            "carrier.frequency",
            "modulatorFrequency.inputs.0"
        ],

        "ratio.outputs.0": "modulatorFrequency.inputs.1",

        "modulatorFrequency.outputs.0": [
            "deviation.inputs.0",
            "modulator.frequency"
        ],

        "index.outputs.0": "deviation.inputs.1",

        "envelope.outputs.0": [
            "modulatorAmplitudeGain.inputs.0",
            "envelopeGain.inputs.0"
        ],

        "deviation.outputs.0": "modulatorAmplitudeGain.inputs.1",
        "modulator.outputs.0": "modulatorOutputGain.inputs.0",
        "modulatorAmplitudeGain.outputs.0": "modulatorOutputGain.gain",
        "modulatorOuptutGain.outputs.0": "carrier.frequency",
        "amplitude.outputs.0": "envelopeGain.gain",
        "envelopeGain.outputs.0": "ouptutGain.gain",
        "carrier.outputs.0": "outputGain.inputs.0",
        "outputGain.outputs.0": "output"
   }
}
